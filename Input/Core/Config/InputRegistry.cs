using System.Linq;
using Godot;
using Godot.Collections;
using System.Text;

[Tool]
[GlobalClass]
public partial class InputRegistry : Resource {
  [Export] public Array<InputActionSchema> Actions { get; private set; }
  [Export] private int _lastGeneratedHash;
  [Export] public string OutputPath { get; private set; } = "res://generated/Actions.gen.cs";

  private string ResolvedPath => OutputPath.StartsWith("res://")
    ? OutputPath
    : "res://" + OutputPath.TrimStart('/');

  [ExportToolButton("Sync Actions to Code")]
  public Callable GenerateButton => Callable.From(RunGenerator);

  [ExportToolButton("Check if Needs Code Sync")]
  public Callable CheckSyncButton => Callable.From(CheckSync);


  /// <summary>
  /// Overridden to make _lastGeneratedHash readonly from the editor.
  /// </summary>
  public override void _ValidateProperty(Dictionary property) {
    if (property["name"].AsStringName() == PropertyName._lastGeneratedHash) {
      property["usage"] = (int)(property["usage"].As<PropertyUsageFlags>() | PropertyUsageFlags.ReadOnly);
    }
  }


  private void CheckSync() {
    if (GetHash() == _lastGeneratedHash)
      GD.Print("✓ Registry is in sync.");
    else
      GD.PushWarning("⚠ Registry out of sync — regenerate.");
  }

  private int GetHash() {
    var sb = new StringBuilder();
    foreach (var schema in Actions.OrderBy(s => s.ActionName.ToString())) {
      sb.Append(schema.AsStringCodeDeclaration());
    }

    return GD.Hash(sb.ToString());
  }

  private void RunGenerator() {
    var sb = new StringBuilder();
    sb.AppendLine("// AUTO-GENERATED by InputRegistry -- do not edit by hand");
    sb.AppendLine(
      "// Instead: 1. Create an InputRegistry resource, 2. Configure all the game's actions on it, 3. click Sync Actions in Code in the GUI");
    sb.AppendLine("using Godot;");
    sb.AppendLine();
    sb.AppendLine("public static class InputActions {");

    foreach (var schema in Actions) {
      sb.AppendLine(schema.AsStringCodeDeclaration());
    }

    sb.AppendLine("}");

    var dir = ResolvedPath.GetBaseDir();
    if (!DirAccess.DirExistsAbsolute(dir)) {
      DirAccess.MakeDirRecursiveAbsolute(dir);
    }

    using var file = FileAccess.Open(ResolvedPath, FileAccess.ModeFlags.Write);
    if (file == null) {
      GD.PushError($"Failed to open {ResolvedPath} for writing: {FileAccess.GetOpenError()}");
      return;
    }

    file.StoreString(sb.ToString());

    _lastGeneratedHash = GetHash();
    ResourceSaver.Save(this);
    GD.Print($"✓ Generated Actions.gen.cs with {Actions.Count} actions.");
  }
}