using System.Linq;
using Godot;
using Godot.Collections;
using System.Text;

[Tool]
[GlobalClass]
public partial class InputRegistry : Resource {
  [Export] public Array<InputActionSchema> Actions { get; private set; }
  [Export] private int _lastGeneratedHash;
  [Export] public string OutputPath { get; private set; } = "res://generated/Actions.gen.cs";

  private string ResolvedPath => OutputPath.StartsWith("res://")
    ? OutputPath
    : "res://" + OutputPath.TrimStart('/');

  [ExportToolButton("Sync Actions as Code", Icon = "ScriptCreate")]
  public Callable GenerateButton => Callable.From(RunGenerator);

  [ExportToolButton("Check if Sync Needed", Icon = "Info")]
  public Callable CheckSyncButton => Callable.From(CheckSync);


  /// <summary>
  /// Overridden to make _lastGeneratedHash readonly from the editor.
  /// </summary>
  public override void _ValidateProperty(Dictionary property) {
    if (property["name"].AsStringName() == PropertyName._lastGeneratedHash) {
      property["usage"] = (int)(property["usage"].As<PropertyUsageFlags>() | PropertyUsageFlags.ReadOnly);
    }
  }


  private void CheckSync() {
    if (GetHash() == _lastGeneratedHash)
      GD.Print("✓ Registry is in sync.");
    else
      GD.PushWarning("⚠ Registry out of sync — regenerate.");
  }

  private int GetHash() {
    return GD.Hash(GenerateOutputString());
  }

  private string GenerateOutputString() {
    var sb = new StringBuilder();
    sb.AppendLine("// AUTO-GENERATED by InputRegistry. Do not edit by hand. How to:");
    sb.AppendLine("//    1. Create an InputRegistry godot Resource");
    sb.AppendLine("//    2. Configure all the game's actions on it");
    sb.AppendLine("//    3. Click Sync Actions as Code in the GUI");
    sb.AppendLine();
    sb.AppendLine("using Godot;");
    sb.AppendLine("using System.Collections.Generic;");
    sb.AppendLine();
    sb.AppendLine("public static class InputActions {");

    foreach (var schema in Actions) {
      sb.AppendLine(schema.AsStringCodeDeclaration());
    }

    sb.AppendLine(
      "    public static readonly IReadOnlyDictionary<StringName, BaseInputAction> All = new Dictionary<StringName, BaseInputAction> {");
    foreach (var schema in Actions) {
      sb.AppendLine(schema.AsStringDictionaryEntry());
    }

    sb.AppendLine("    };");
    sb.AppendLine("}");

    return sb.ToString();
  }

  private void RunGenerator() {
    var output = GenerateOutputString();

    var dir = ResolvedPath.GetBaseDir();
    if (!DirAccess.DirExistsAbsolute(dir)) {
      DirAccess.MakeDirRecursiveAbsolute(dir);
    }

    using var file = FileAccess.Open(ResolvedPath, FileAccess.ModeFlags.Write);
    if (file == null) {
      GD.PushError($"Failed to open {ResolvedPath} for writing: {FileAccess.GetOpenError()}");
      return;
    }

    file.StoreString(output);

    _lastGeneratedHash = GetHash();
    ResourceSaver.Save(this);
    GD.Print($"✓ Generated Actions.gen.cs with {Actions.Count} actions.");
  }
}